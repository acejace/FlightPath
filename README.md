Dataset.

The data set used is from <https://www.kaggle.com/usdot/flight-delays> which includes various information regarding US domestic flights. Our code parses the CSV file provided into an array that contains the information required for each flight. This array is then used to build the  graph where each vertex represents an airport and each directed edge a flight. For our testing purposes we use the ORIGIN_AIRPORT and DESTINATION_AIRPORT columns of the dataset which provide a unique IATA code for the origin and destination airports of each flight. The AIR_TIME column gives us the total duration of the flight, and by subtracting AIR_TIME from ELAPSED_TIME (total flight time including airport delays) we get the waiting time at each connecting airport. All times are given in minutes. Our dataset does not include pricing information, as prices fluctuate depending on time, so for testing purposes we are calculating a price for each flight as a function of AIR_TIME and some small random value.

```java
public class FlightInfo {
    public String flightNumber; // Uniquely identifies the flight
    public String origin;       // IATA airport code for origin
    public String destination;  // Destination airport code
    public int elapsedTime;
    public int airTime;
    public int waitTime;
    public double price;
}
```

The array of FlightInfo is then used to create the graph. We use the origin and destination values to join nodes in the graph. The airTime, waitTime and price are used to calculate the weight (cost) of each edge.


Implementation

We represented flights as edges and airports as vertices of a directed graph, and encoded the graph as an adjacent list with a hashtable. All airports are added before we construct any edges, so we can ensure edges only connect vertices that exist in the graph. Each time we add a new edge, we calculate the cost of each flight, and insert the cost number of dummy nodes between the original and the destination. After all edges are added, we perform a modified dfs search algorithm, instead of collecting visited nodes, we start from the starting node and search for the target node. Each time we visit the adjacent nodes of a node, we set predecessors of adjacent nodes, so we can trace back from the chain of references. If the target node is hit, we call the traceback function, which only collects airport nodes in the chain.

Here is a snippet of the traceback function:
```
  public ArrayList<Node> traceback(Node goal) {
    assert (pred != null);

    Node pred = this.pred;
    ArrayList<Node> path = new ArrayList<Node>();
    path.add(this);
    while (pred != goal) {
      if (goal != null && pred == null) {
        throw new Exception(msg);
      }
        path.add(pred);
        pred = pred.pred;
      }
    path.add(goal);
    return path;
  }

```
There might be multiple paths between two adjacent airports, but the path that is chosen can only be the shortest. So after we get a list of hoops, we search for flights between two adjacent airports that have the lowest cost.  This flight is guaranteed to be the flight used by dfs (BFS).
To test the program, we first search two airports that are not adjacent in the data set. For example, airport “SFO” and airport “MIA”. In the first 1000 data samples we have two possible routes to connect these two nodes: “SFO” -> “DFW” -> “MIA” or “SFO” -> “IAH” -> “MIA”. We add up the total cost of all possible routes from “SFO” to “MIA”, and compare the path that gives the shortest cost and the one that is generated by the algorithm.














Results


Plot 1. Algorithm runtimes VS |V|+|E|



According to our predictions, our algorithm has O(|V|+|E|) runtime complexity.
We run our different input values, recorded |V|, |E| and time elapsed values for each run.

When plotted against |V|+|E|, algorithm runtimes appear to grow linearly. A linear fit shows that Runtime(|V|+|E|)=0.04(|V|+|E|)-1.13 is a good approximation for the runtime complexity function. Therefore, our algorithm is O(|V|+|E|), as expected.

It’s worth noting that the best case for O(|V|+|E|) is heavily related to the nature of the graph. At one end, If the graph is shaped as a linked list, we have the best case linear time for searching. On the other hand, if the graph is complete, the time complexity will be O(|V|^2). Typically, the more edges the graph has, the worse the running time will be. Before we run the algorithm and plot the graph, we did not know how dense flights are, but we expected it to be somewhere between a linear line and exponential growth. The result shows a strong linear tendency, thus we can conclude that direct flights between cities tend to be sparse.

For BFS, for each node we need to check whether its adjacent nodes are already visited. If they are, we know we do not need to visit them any more. In our first attempt, we check the inclusion by adding visited nodes to a buffer, and when we encounter a node next time, check if it is a member of the buffer. This operation is clearly O(n), and it happens for all adjacent nodes. To improve the performance, we tagged a boolean value to each node to indicate whether it’s visited or not. The testing time becomes O(1) and the speed improves significantly. 

In terms of implementation, there is a lot of room for improvement. Currently after we obtained the shortest path, we need to  refer back to the data table to check which flights correspond to the path. We can encode the flight information into an adjacent list so we can find the right edge in constant time.

Matlab code used for the plots:

```
P=polyfit(inputSize,runtimes,1);
 
x=0:1200;
yfit = P(1)*x+P(2);
hold on
scatter(inputSize,runtimes);
xlabel('|V|+|E|');
ylabel('Runtime');
plot(x,yfit,'r-.');
legend('Runtimes VS (|V|+|E|)',sprintf('%.2f*(|V|+|E|)+(%.2f)',P(1),P(2)));
hold off
```

Unexpected Cases/Difficulties. 

Although we have lots of flights, most of them are repetitive. For a set of flights between two airports, the shortest one will be the one that represents the path and is always picked to find the shortest path. In this case It’s  redundant to search for a longer path.  We can achieve better running time if we can trim cases like this. We didn’t expect there to be a time dependency between flights. After we pick a certain flight with an arrival time, edges from the destination with start time earlier should be invalidated, and the difference between end of last flight and start of next flight should be considered as part of the weight too.

Task separation and responsibilities:
Jinyang Yao: Algorithm implementation
Jace Lai: Unexpected Cases and task separation
Lucas Pozza: Dataset implementation
Tatiana Urazova: Results analysis and testing
